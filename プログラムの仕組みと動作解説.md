# プログラムの仕組みと動作解説

このドキュメントは、CME FedWatch データ取得ツールがどのように動作するかを詳しく解説します。

## 📋 目次

1. [プログラム全体の流れ](#プログラム全体の流れ)
2. [主要な機能の解説](#主要な機能の解説)
3. [使用している技術](#使用している技術)
4. [データフロー図](#データフロー図)
5. [各処理の詳細解説](#各処理の詳細解説)
6. [エラーハンドリング](#エラーハンドリング)
7. [よくある質問（技術的な観点）](#よくある質問技術的な観点)

---

## プログラム全体の流れ

プログラムは以下の3つの主要な部分で構成されています：

```
┌─────────────────────────────────────────────────────────┐
│  1. 初期化・認証設定                                      │
│     - Googleスプレッドシートへの認証を準備                 │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│  2. データ取得（スクレイピング）                           │
│     - CME FedWatchサイトにアクセス                        │
│     - ブラウザでページを開く                              │
│     - データを抽出                                        │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│  3. データ処理・書き込み                                   │
│     - 前回値と比較                                        │
│     - 矢印と増減率を計算                                  │
│     - スプレッドシートに書き込み                          │
└─────────────────────────────────────────────────────────┘
```

### 実行の流れ（シーケンス図）

```
開始
  │
  ├─→ [認証設定] Googleスプレッドシートの認証情報を読み込む
  │
  ├─→ [ブラウザ起動] Playwrightでブラウザを起動
  │
  ├─→ [ページアクセス] CME FedWatchのページを開く
  │
  ├─→ [データ抽出] テーブルから確率データを取得
  │     ├─ ヘッダー行を取得
  │     ├─ データ行を取得
  │     └─ セルの背景色を取得
  │
  ├─→ [前回値読み込み] 「前回値」シートから前回のデータを読み込む
  │
  ├─→ [比較処理] 現在値と前回値を比較して矢印を決定
  │
  ├─→ [書き込み] メインシートにデータを書き込む
  │
  ├─→ [色設定] セルの背景色を適用
  │
  ├─→ [前回値保存] 現在のデータを「前回値」シートに保存
  │
  └─→ 終了
```

---

## 主要な機能の解説

### コードの構造について

このプログラムは、コードの可読性と保守性を向上させるため、以下の最適化が行われています：

1. **設定定数の導入（10-30行目）**
   - マジックナンバー（直接書かれた数字）を定数として定義
   - 設定を変更する際は、プログラム上部の定数を変更するだけ
   - 例：`MAX_RETRIES = 3`、`WAIT_AFTER_PAGE_LOAD = 3` など

2. **関数の分割**
   - 大きな関数を小さな関数に分割
   - 各関数が単一の責任を持つように設計
   - メイン関数 `scrape_fed_data()` が約70行に短縮（元の約280行から）

3. **エラーハンドリングの改善**
   - 特定の例外のみを捕捉（`except:` ではなく `except Exception:`）
   - エラー発生箇所の特定が容易

### 1. 認証設定（33-48行目）

**何をしているか：**
Googleスプレッドシートにアクセスするための認証情報を設定します。

**詳しく解説：**

```python
# 1. 必要な権限を指定
scopes = [
    "https://www.googleapis.com/auth/spreadsheets",  # スプレッドシートへのアクセス権
    "https://www.googleapis.com/auth/drive"          # Google Driveへのアクセス権
]

# 2. 認証方法を選択（環境変数かファイルか）
if os.environ.get("GCP_SA_KEY"):
    # GitHub Actionsなどで実行する場合：環境変数から読み込む
    creds = Credentials.from_service_account_info(json.loads(key_json), scopes=scopes)
else:
    # ローカルで実行する場合：service_account.jsonファイルから読み込む
    creds = Credentials.from_service_account_file('service_account.json', scopes=scopes)

# 3. gspreadライブラリで認証
gc = gspread.authorize(creds)
```

**なぜ必要なのか：**
- Googleスプレッドシートは認証が必要なサービスです
- サービスアカウントという「プログラム用のアカウント」を使用して、人間がログインしなくても自動でアクセスできるようにします

**具体例：**
```
人間：「Googleにログインしてスプレッドシートを開く」
プログラム：「service_account.jsonという証明書を使って、私がプログラムであることを証明し、スプレッドシートにアクセスする」
```

### 2. データ取得（スクレイピング）（264-330行目）

**何をしているか：**
CME FedWatchのウェブサイトにアクセスして、確率データを自動的に取得します。

**プログラムの構造：**
- コードは複数の小さな関数に分割されています
  - `_launch_browser()`: ブラウザを起動
  - `_navigate_to_page()`: ページに遷移
  - `_find_iframe()`: iframeを検索
  - `_click_probabilities()`: Probabilitiesタブをクリック
  - `_find_table()`: テーブルを検索
  - `_extract_table_header()`: ヘッダー行を取得
  - `_extract_table_rows()`: データ行を取得
  - `_parse_color_to_rgb()`: 色情報を変換

**詳しく解説：**

#### 2-1. ブラウザの起動（52-74行目）

```python
with sync_playwright() as p:
    # Chromiumブラウザを起動
    browser = p.chromium.launch(
        headless=False,  # ブラウザを画面に表示（デバッグ用）
        args=[
            '--disable-blink-features=AutomationControlled',  # 自動化を検出されにくくする
            '--disable-http2',  # HTTP/2を無効化（エラー回避）
            # ... その他のオプション
        ]
    )
```

**なぜPlaywrightを使うのか：**
- CME FedWatchのページは、JavaScriptで動的にデータを読み込む「動的サイト」です
- 通常のHTTPリクエストだけでは、JavaScriptで生成されたデータを取得できません
- Playwrightは実際のブラウザを操作するので、JavaScriptで生成された内容も取得できます

**具体例：**
```
通常の方法（HTTPリクエスト）：
「このURLのHTMLをください」→ 空のページが返ってくる（JavaScriptがまだ実行されていない）

Playwrightの方法：
「ブラウザを起動して、このページを開き、JavaScriptを実行して、完成したページのデータをください」
→ 完全に読み込まれたページのデータが取得できる
```

#### 2-2. ページへのアクセス（76-95行目）

```python
# CME FedWatchの日本語版ページにアクセス
url = "https://www.cmegroup.com/ja/markets/interest-rates/cme-fedwatch-tool.html"
page.goto(url, wait_until="domcontentloaded", timeout=120000)
```

**`wait_until="domcontentloaded"` とは：**
- ページの基本的な構造（HTML）が読み込まれるまで待つ
- `load` よりも早く、`networkidle` よりも確実に待機できる

**なぜ待機時間を入れるのか：**
```python
time.sleep(3)  # ページが完全に読み込まれるまで待つ
time.sleep(5)  # 追加の待機時間
```
- JavaScriptでデータを読み込むのに時間がかかる
- データが読み込まれる前に取得しようとすると、エラーになる
- 確実にデータが読み込まれるように、少し待機する

#### 2-3. iframe内のデータを取得（97-122行目）

```python
# iframe（ページの中に埋め込まれた別のページ）を探す
iframe_selectors = [
    "iframe[src*='quikstrike']",
    "iframe[src*='fedwatch']",
    "iframe"
]

frame = None
for selector in iframe_selectors:
    iframes = page.locator(selector).all()
    if iframes:
        frame = page.frame_locator(selector).first
        break
```

**iframeとは：**
- 「ページの中に埋め込まれた別のページ」のようなもの
- CME FedWatchのページは、メインページの中に、データ表示用のiframeを埋め込んでいます
- データはこのiframeの中にあるため、iframeを特定する必要があります

**具体例：**
```
ページ構造：
┌─────────────────────────────────┐
│ メインページ（CMEのサイト）       │
│  ┌───────────────────────────┐ │
│  │ iframe（データ表示エリア） │ │ ← ここにデータがある
│  │  - テーブル                │ │
│  │  - 確率データ              │ │
│  └───────────────────────────┘ │
└─────────────────────────────────┘
```

#### 2-4. 「Probabilities」タブをクリック（124-148行目）

```python
# 複数の方法で「Probabilities」リンクを探す
prob_selectors = [
    "text=Probabilities",           # テキストが「Probabilities」の要素
    "a:has-text('Probabilities')",  # 「Probabilities」というテキストを含むリンク
    # ... その他のパターン
]

for selector in prob_selectors:
    prob_link = frame.locator(selector).first
    if prob_link.is_visible(timeout=5000):
        prob_link.click()  # クリック
        break
```

**なぜ複数のセレクタを試すのか：**
- ウェブサイトの構造は変わる可能性がある
- 一つの方法で見つからなくても、別の方法で見つけられるようにする
- エラーに対する堅牢性（ロバストネス）を高める

#### 2-5. テーブルからデータを取得（150-237行目）

**ヘッダー行の取得（167-184行目）：**

```python
# テーブルのヘッダー行（1行目）を取得
header_selectors = ["thead tr", "table tr:first-child", "tr:first-child"]

for selector in header_selectors:
    header = frame.locator(selector).first
    header_cells = header.locator("th, td").all()  # th（見出しセル）とtd（データセル）を取得
    if len(header_cells) > 0:
        header_row = [cell.inner_text() for cell in header_cells]
        # 例: ["Meeting Date", "0.0-0.25%", "0.25-0.50%", ...]
        break
```

**データ行の取得（186-237行目）：**

```python
data_rows = []
cell_colors = []  # 各セルの背景色も保存

for row in rows[start_idx:]:  # ヘッダー行を除く
    row_data = []
    row_color_info = []
    
    for cell in row.locator("td, th").all():
        # セルのテキストを取得
        cell_text = cell.inner_text()
        row_data.append(cell_text.strip())
        
        # セルの背景色を取得（JavaScriptで実行）
        bg_color = cell.evaluate("""
            el => {
                const style = window.getComputedStyle(el);
                return style.backgroundColor;
            }
        """)
        
        # RGB値をGoogleスプレッドシート形式に変換
        # rgb(255, 0, 0) → {'red': 1.0, 'green': 0.0, 'blue': 0.0}
        rgb_color = convert_to_rgb(bg_color)
        row_color_info.append(rgb_color)
    
    data_rows.append(row_data)
    cell_colors.append(row_color_info)
```

**なぜ色情報も取得するのか：**
- CMEサイトでは、確率の高さを色で表現している（例：確率が高い=濃い色）
- この色情報をスプレッドシートにも反映させることで、視覚的にわかりやすくする

**`cell.evaluate()` とは：**
- Playwrightの機能で、セル内でJavaScriptコードを実行できる
- ブラウザの`getComputedStyle()`関数を使って、実際に表示されている色を取得する

#### 2-6. エラーハンドリングとリトライ（264-330行目）

```python
MAX_RETRIES = 3  # 最大3回まで再試行

for attempt in range(MAX_RETRIES):
    try:
        # スクレイピング処理
        ...
        return data  # 成功したらデータを返す
    except Exception as e:
        if attempt < MAX_RETRIES - 1:
            time.sleep(RETRY_DELAY)  # 10秒待ってから再試行
            continue
        # 3回試行しても失敗したらエラー
```

**なぜリトライするのか：**
- ネットワークの一時的なエラー
- ページの読み込みが遅い
- サイト側の一時的な問題

これらは一時的なものなので、少し待ってから再試行すると成功することが多いです。

**プログラムの構造について：**
- コードは複数の小さな関数に分割されています（関数分割）
- ブラウザ起動、ページ遷移、データ取得など、各処理が独立した関数になっています
- これにより、コードの可読性と保守性が向上しています

### 3. データ処理・書き込み（333-497行目）

**何をしているか：**
取得したデータを処理して、前回値と比較し、スプレッドシートに書き込みます。

#### 3-1. スプレッドシートを開く（334-336行目）

```python
spreadsheet = gc.open(SPREADSHEET_NAME)  # スプレッドシートを開く（定数を使用）
sh = spreadsheet.sheet1  # 1つ目のシート（メインシート）を取得
now = datetime.now().strftime("%Y-%m-%d %H:%M")  # 現在時刻を取得
```

**設定定数について：**
- プログラムの上部（10-30行目）に設定定数が定義されています
- `SPREADSHEET_NAME = "CME定期調査"` など、設定値を一箇所で管理しています

#### 3-2. 「前回値」シートの準備（338-358行目）

```python
previous_sheet_name = "前回値"
try:
    previous_sheet = spreadsheet.worksheet(previous_sheet_name)
except gspread.exceptions.WorksheetNotFound:
    # シートが存在しない場合は作成
    previous_sheet = spreadsheet.add_worksheet(title=previous_sheet_name, rows=100, cols=20)

# 前回のデータを読み込む
previous_values = previous_sheet.get_all_values()
previous_data = previous_values[1:] if len(previous_values) > 1 else []
```

**なぜ「前回値」シートが必要なのか：**
- 前回の実行時のデータを保存しておく
- 今回のデータと比較して、増減を計算するため
- 矢印（↑↓→）と増減率を表示するため

**データ構造の例：**
```
前回値シート：
取得日時 | 空列 | 会合日 | 0.0-0.25% | 0.25-0.50% | ...
---------|------|--------|-----------|------------|----
2024-01-07 09:00 | | 2024-01-31 | 88.4% | 11.6% | ...
```

#### 3-3. 数値抽出関数（360-382行目）

```python
def extract_number(value):
    """セルから数値を抽出（例: '88.4% ↑' → 88.4）"""
    if not value or not isinstance(value, str):
        return None
    try:
        # %記号と矢印を除去して数値を抽出
        match = re.search(r'(\d+\.?\d*)', value.replace('%', '').replace('↑', '').replace('↓', '').replace('→', '').strip())
        if match:
            return float(match.group(1))
    except:
        pass
    return None
```

**なぜ必要なのか：**
- スプレッドシートのセルには「88.4% ↑ +2.1%」のような形式で保存されている
- 比較するためには、数値部分（88.4）だけを抽出する必要がある

**具体例：**
```python
extract_number("88.4% ↑ +2.1%")  # → 88.4
extract_number("11.6% ↓ -1.2%")  # → 11.6
extract_number("2024-01-31")     # → None（数値ではない）
```

#### 3-4. 前回値との比較と矢印の決定（384-438行目）

```python
for row_idx, row in enumerate(table_data['rows']):
    row_with_date = [now, '']  # 取得日時 + 空列
    
    for col_idx, current_val in enumerate(row):
        arrow = ""
        change_text = ""
        
        # 確率値（%を含む）の場合のみ矢印を付ける
        if current_val and '%' in str(current_val):
            # 前回値を取得
            previous_val = None
            if previous_data and row_idx < len(previous_data):
                previous_val_str = previous_data[row_idx][col_idx + 2]  # 取得日時+空列の2列を考慮
                previous_val = extract_number(previous_val_str)
            
            current_num = extract_number(current_val)
            
            # 比較して矢印を決定
            if current_num is not None and previous_val is not None:
                diff = current_num - previous_val
                if abs(diff) > 0.1:  # 0.1%以上の変化がある場合
                    if diff > 0:
                        arrow = " ↑"
                        change_text = f" +{diff:.1f}%"
                    else:
                        arrow = " ↓"
                        change_text = f" {diff:.1f}%"  # 負の値なので"-"は自動で付く
                else:
                    arrow = " →"
                    change_text = " ±0.0%"
            
            cell_value = current_val + arrow + change_text
            row_with_date.append(cell_value)
```

**処理の流れ：**

1. **確率値かどうかを判定**：`'%' in str(current_val)` で、%記号が含まれているかチェック
2. **前回値を取得**：同じ行・同じ列の前回値を取得
3. **数値に変換**：`extract_number()` で数値部分だけを抽出
4. **差分を計算**：`diff = current_num - previous_val`
5. **矢印を決定**：
   - `diff > 0` かつ `abs(diff) > 0.1` → ↑（増加）
   - `diff < 0` かつ `abs(diff) > 0.1` → ↓（減少）
   - `abs(diff) <= 0.1` → →（変化なし）

**具体例：**
```
前回値: 88.4%
現在値: 90.5%
差分: 90.5 - 88.4 = 2.1

結果: "90.5% ↑ +2.1%"
```

```
前回値: 88.4%
現在値: 88.3%
差分: 88.3 - 88.4 = -0.1（絶対値0.1以下）

結果: "88.3% → ±0.0%"
```

**なぜ0.1%の閾値を設けるのか：**
- 微小な変化（例：0.05%）は、誤差や表示の丸めの可能性がある
- 0.1%以上の変化のみを「有意な変化」として扱う
- ノイズを減らすため

#### 3-5. スプレッドシートへの書き込み（440-446行目）

```python
# 既存のデータをクリア（全て）
sh.clear()

# 一括で書き込み
if len(all_data) > 0:
    sh.update(values=all_data, range_name='A1')
```

**なぜ `sh.clear()` するのか：**
- 前回のデータが残っていると、新しいデータと混在してしまう
- 常に最新のデータだけを表示するため

**`range_name='A1'` とは：**
- A1セル（左上）から書き込みを開始する
- データは自動的に下方向・右方向に展開される

#### 3-6. 背景色の適用（452-487行目）

```python
if 'cell_colors' in table_data and table_data['cell_colors']:
    cell_colors = table_data['cell_colors']
    start_row = 2 if table_data['header'] else 1  # ヘッダー行を考慮
    
    for row_idx, row_colors in enumerate(cell_colors):
        sheet_row = start_row + row_idx
        
        for col_idx, color_info in enumerate(row_colors):
            if color_info is not None:
                # 列番号を列文字に変換（1 → 'A', 2 → 'B', ...）
                col_letter = col_num_to_letter(col_idx + 3)  # 取得日時+空列の2列を考慮
                cell_range = f"{col_letter}{sheet_row}"
                
                # 背景色を設定
                sh.format(cell_range, {
                    "backgroundColor": color_info  # {'red': 1.0, 'green': 0.0, 'blue': 0.0}
                })
```

**`col_num_to_letter()` 関数（361-368行目）：**

```python
def col_num_to_letter(n):
    """列番号（1始まり）を列文字（A, B, C, ...）に変換"""
    result = ""
    while n > 0:
        n -= 1
        result = chr(65 + (n % 26)) + result
        n //= 26
    return result
```

**なぜこの関数が必要なのか：**
- Google Sheets APIは、セルの位置を「A1」「B2」のような文字列で指定する
- プログラムでは列番号（1, 2, 3, ...）で処理する方が簡単
- 変換が必要になる

**具体例：**
```python
col_num_to_letter(1)   # → "A"
col_num_to_letter(2)   # → "B"
col_num_to_letter(26)  # → "Z"
col_num_to_letter(27)  # → "AA"
```

#### 3-7. 前回値の保存（489-495行目）

```python
# 現在のデータを「前回値」シートに保存
previous_sheet.clear()
previous_sheet.update(values=all_data, range_name='A1')
```

**なぜ最後に保存するのか：**
- 次回の実行時に、今回のデータを「前回値」として比較するため
- 実行のたびに最新のデータで更新する

---

## 使用している技術

### 1. Python

**なぜPythonを使うのか：**
- ウェブスクレイピングに適したライブラリが豊富
- コードが読みやすく、メンテナンスしやすい
- データ処理に優れている

### 2. Playwright

**Playwrightとは：**
- ブラウザを自動操作するためのライブラリ
- Chromium、Firefox、WebKitをサポート
- JavaScriptで生成される動的なコンテンツも取得可能

**主な機能：**
- ブラウザの起動・操作
- ページのナビゲーション
- 要素の検索・クリック
- JavaScriptの実行
- スクリーンショットの取得

### 3. gspread

**gspreadとは：**
- Google Sheets APIを簡単に使えるPythonライブラリ
- スプレッドシートの読み書きが簡単

**主な機能：**
- スプレッドシートの開閉
- シートの作成・削除
- データの読み書き
- セルのフォーマット設定

### 4. Google Sheets API

**Google Sheets APIとは：**
- Googleスプレッドシートをプログラムから操作するためのAPI
- RESTful APIで、HTTPリクエストで操作する
- サービスアカウントを使用した認証に対応

### 5. サービスアカウント認証

**サービスアカウントとは：**
- プログラム用のGoogleアカウント
- 人間がログインする必要がない
- JSONキーファイルで認証する

**なぜ必要なのか：**
- 自動実行時に、人間がログインできない
- セキュアに認証するため

---

## データフロー図

```
┌─────────────────────┐
│  CME FedWatchサイト │
│  (ウェブページ)      │
└──────────┬──────────┘
           │
           │ HTTPリクエスト
           ↓
┌─────────────────────┐
│  Playwright         │
│  (ブラウザ操作)      │
│  - ページを開く      │
│  - iframeを探す      │
│  - テーブルを取得    │
└──────────┬──────────┘
           │
           │ データ抽出
           ↓
┌─────────────────────┐
│  データ構造          │
│  {                   │
│    header: [...],    │
│    rows: [[...]],    │
│    cell_colors: [...]│
│  }                   │
└──────────┬──────────┘
           │
           │ 前回値と比較
           ↓
┌─────────────────────┐
│  前回値シート        │
│  (Google Sheets)     │
└──────────┬──────────┘
           │
           │ 差分計算
           ↓
┌─────────────────────┐
│  データ処理          │
│  - 矢印追加          │
│  - 増減率計算        │
└──────────┬──────────┘
           │
           │ 書き込み
           ↓
┌─────────────────────┐
│  メインシート        │
│  (Google Sheets)     │
│  - データ書き込み     │
│  - 色設定            │
└─────────────────────┘
           │
           │ 保存
           ↓
┌─────────────────────┐
│  前回値シート更新    │
│  (次回実行時のため)   │
└─────────────────────┘
```

---

## 各処理の詳細解説

### エラーハンドリングの仕組み

#### 1. 階層的なリトライ

```
Chromiumで試行（最大3回）
  ├─ 1回目: 失敗 → 10秒待機して再試行
  ├─ 2回目: 失敗 → 10秒待機して再試行
  └─ 3回目: 失敗 → エラー終了
```

**注意：** このプログラムはChromiumのみを使用します。Firefoxへの切り替え機能は削除されています。

#### 2. セレクタの複数パターン

要素を探す際に、複数のセレクタパターンを試します：

```python
# iframeを探す
iframe_selectors = [
    "iframe[src*='quikstrike']",  # パターン1
    "iframe[src*='fedwatch']",    # パターン2
    "iframe"                      # パターン3（フォールバック）
]

# Probabilitiesリンクを探す
prob_selectors = [
    "text=Probabilities",           # パターン1
    "a:has-text('Probabilities')",  # パターン2
    "[data-item='Probabilities']",  # パターン3
    # ... その他
]
```

**なぜ複数パターンを使うのか：**
- サイトの構造が変わる可能性がある
- 一つの方法で見つからなくても、別の方法で見つけられる

#### 3. タイムアウトの設定

```python
page.goto(url, wait_until="domcontentloaded", timeout=120000)  # 120秒（2分）まで待つ
header.wait_for(state="attached", timeout=5000)  # 5秒まで待つ
```

**なぜタイムアウトを設けるのか：**
- 無限に待ち続けることを防ぐ
- エラーが発生した場合に、適切なタイミングで処理を中断する

### データ構造の説明

#### 取得データの構造

```python
table_data = {
    'header': ['会合日', '0.0-0.25%', '0.25-0.50%', '0.50-0.75%', ...],
    'rows': [
        ['2024-01-31', '88.4%', '11.6%', '0.0%', ...],
        ['2024-03-20', '75.2%', '24.8%', '0.0%', ...],
        # ... その他の行
    ],
    'cell_colors': [
        [None, {'red': 0.9, 'green': 0.1, 'blue': 0.1}, {'red': 0.1, 'green': 0.9, 'blue': 0.1}, ...],
        [None, {'red': 0.8, 'green': 0.2, 'blue': 0.1}, {'red': 0.2, 'green': 0.8, 'blue': 0.1}, ...],
        # ... その他の行の色情報
    ]
}
```

**`cell_colors` の構造：**
- 2次元配列で、`[行][列]` の形式
- 各要素は `{'red': 0.0-1.0, 'green': 0.0-1.0, 'blue': 0.0-1.0}` または `None`
- `None` は色が設定されていない（例：取得日時列）

---

## エラーハンドリング

### 1. 認証エラー

**発生するケース：**
- `service_account.json` が見つからない
- 認証キーが無効
- スプレッドシートへのアクセス権限がない

**対処方法：**
```python
if os.path.exists(SERVICE_ACCOUNT_FILE):
    creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=scopes)
else:
    raise FileNotFoundError(f"認証ファイルが見つかりません: {SERVICE_ACCOUNT_FILE}")
```

### 2. スクレイピングエラー

**発生するケース：**
- ページが読み込まない
- iframeが見つからない
- テーブルが見つからない
- ネットワークエラー

**対処方法：**
- 最大3回まで再試行
- 複数のブラウザタイプを試す
- 複数のセレクタパターンを試す

### 3. スプレッドシートエラー

**発生するケース：**
- スプレッドシートが見つからない
- シートが見つからない
- 書き込み権限がない

**対処方法：**
```python
try:
    previous_sheet = spreadsheet.worksheet(previous_sheet_name)
except gspread.exceptions.WorksheetNotFound:
    # シートが存在しない場合は作成
    previous_sheet = spreadsheet.add_worksheet(title=previous_sheet_name, rows=100, cols=20)
```

---

## よくある質問（技術的な観点）

### Q1: なぜheadless=Falseに設定されているのか？

**A:** デバッグを容易にするためです。`headless=True`にすると、ブラウザが画面に表示されず、エラーが発生したときに原因を特定しにくくなります。

**本番環境での推奨設定：**
```python
headless=True  # バックグラウンドで実行（パフォーマンスが向上）
```

### Q2: なぜHTTP/2を無効化しているのか？

**A:** CMEサイトでHTTP/2を使用すると、エラーが発生することがあるためです。HTTP/1.1の方が安定しています。

```python
'--disable-http2',  # HTTP/2を無効化（重要）
```

### Q3: なぜ待機時間（sleep）が多く使われているのか？

**A:** JavaScriptで動的にデータを読み込むサイトでは、データが読み込まれるまで待つ必要があるためです。短すぎると、データが読み込まれる前に取得しようとしてエラーになります。

### Q4: なぜ複数のセレクタパターンを試すのか？

**A:** ウェブサイトの構造は変わる可能性があるためです。一つの方法で見つからなくても、別の方法で見つけられるようにすることで、プログラムの堅牢性を高めています。

### Q5: スプレッドシートに書き込む際、なぜ全てクリアするのか？

**A:** 前回のデータが残っていると、新しいデータと混在してしまうためです。常に最新のデータだけを表示するために、書き込む前に全てクリアします。

### Q6: なぜ「前回値」シートを別に作成するのか？

**A:** メインシートには取得日時も含まれるため、直接比較するのが難しいためです。前回値シートには、比較に必要なデータのみを保存し、形式を統一しています。

---

## まとめ

このプログラムは、以下のような仕組みで動作しています：

1. **認証**: サービスアカウントでGoogle Sheetsにアクセス
2. **スクレイピング**: Playwrightでブラウザを操作し、CMEサイトからデータを取得
3. **処理**: 前回値と比較して、矢印と増減率を計算
4. **書き込み**: Googleスプレッドシートにデータと色情報を書き込む

エラーハンドリングやリトライ機能により、ネットワークの一時的な問題やサイトの構造変更にも対応できるようになっています。

---

**作成日**: 2024年1月
**最終更新**: 2024年1月
